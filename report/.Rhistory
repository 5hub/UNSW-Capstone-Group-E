#dem_sa <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_sa.csv'), header = T)
# Can we get this to work?
#fcst_nsw <- read.csv(unz('H03-2021/forecastdemand_nsw.csv.zip.partaa', 'forecastdemand_nsw.csv'), header = T)
## Have a look at how our data has been imported
#head(temp_nsw)
#head(temp_vic)
#head(temp_qld)
#head(temp_sa)
# We can merge the demand and temperature data. This is essentially what we should be working with in order to create our models
# Get rid of columns that we don't require
temp_nsw <- temp_nsw[-c(1)]
#temp_vic <- temp_vic[-c(1)]
#temp_qld <- temp_qld[-c(1)]
#temp_sa <- temp_sa[-c(1, 2)]
dem_nsw <- dem_nsw[-c(3)]
#dem_vic <- dem_vic[-c(3)]
#dem_qld <- dem_qld[-c(3)]
#dem_sa <- dem_sa[-c(3)]
# Convert the DATETIME columns to similar formats in order to merge successfully
########### For some reason temp_vic and dem_vic will not recognize/convert to AEDT which it should be. I have made a work-around by converting everything to AEST however the values of time_vic and dem_vic are incorrect as it gets set as AEST straight away instead of being set to AEDT then converted to AEST. Maybe this an issue with my local system timezone?
########### I note here that unless you use head(temp_vic) the datetimes do not explicitly state that they are AEDT/AEST etc
temp_nsw$DATETIME <- as.POSIXct(temp_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#temp_vic$DATETIME <- as.POSIXct(temp_vic$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Melbourne")
#temp_qld$DATETIME <- as.POSIXct(temp_qld$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Brisbane")
#temp_sa$DATETIME <- as.POSIXct(temp_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
dem_nsw$DATETIME <- as.POSIXct(dem_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#dem_vic$DATETIME <- as.POSIXct(dem_vic$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Melbourne")
#dem_qld$DATETIME <- as.POSIXct(dem_qld$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Brisbane")
#dem_sa$DATETIME <- as.POSIXct(dem_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
## Convert all times to AEST ##### This is only necessary if we wish to compare the data across the whole country at a single point in time.
#temp_nsw$DATETIME <- with_tz(temp_nsw$DATETIME, tzone = "Australia/Brisbane")
#temp_qld$DATETIME <- with_tz(temp_qld$DATETIME, tzone = "Australia/Brisbane")
#temp_sa$DATETIME <- with_tz(temp_sa$DATETIME, tzone = "Australia/Brisbane")
#dem_nsw$DATETIME <- with_tz(dem_nsw$DATETIME, tzone = "Australia/Brisbane")
#dem_qld$DATETIME <- with_tz(dem_qld$DATETIME, tzone = "Australia/Brisbane")
#dem_sa$DATETIME <- with_tz(dem_sa$DATETIME, tzone = "Australia/Brisbane")
# Split DATETIME column into Date and Time columns
temp_nsw$Date <- as.Date(temp_nsw$DATETIME)
temp_nsw$Time <- format(as.POSIXct(temp_nsw$DATETIME), format = "%H:%M:%S")
temp_nsw <- temp_nsw[-c(1)]
dem_nsw$Date <- as.Date(dem_nsw$DATETIME)
dem_nsw$Time <- format(as.POSIXct(dem_nsw$DATETIME), format = "%H:%M:%S")
dem_nsw <- dem_nsw[-c(1)]
temp_nsw[rowSums(is.na(temp_nsw)) > 0, ]
dem_nsw[rowSums(is.na(dem_nsw)) > 0, ]
# Fill in the missing date values with the last valid date
temp_nsw <- temp_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
dem_nsw <- dem_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
# Get rid of the extra row of NaN values for temp_nsw
temp_nsw <- temp_nsw[-14314, ]
# Create lists of row index values
missing_temp_dates <- which(is.na(temp_nsw$Time))
missing_dem_dates <- which(is.na(dem_nsw$Time))
# Split these lists into indexs that correspond to 2:00 and 2:30
two_oclock_temp_rows <- missing_temp_dates[seq(1, length(missing_temp_dates), 2)]
two_thirty_temp_rows <- missing_temp_dates[seq(0, length(missing_temp_dates), 2)]
two_oclock_dem_rows <- missing_dem_dates[seq(1, length(missing_dem_dates), 2)]
two_thirty_dem_rows <- missing_dem_dates[seq(0, length(missing_dem_dates), 2)]
# Enter the values as required
for (i in two_oclock_temp_rows){
temp_nsw[i, 3] <- '02:00:00'
}
for (i in two_thirty_temp_rows){
temp_nsw[i, 3] <- '02:30:00'
}
for (i in two_oclock_dem_rows){
dem_nsw[i, 3] <- '02:00:00'
}
for (i in two_thirty_dem_rows){
dem_nsw[i, 3] <- '02:30:00'
}
# Make sure all columns are in the correct format
temp_nsw$Time <- strptime(temp_nsw$Time, "%H:%M:%S", tz = "Australia/Sydney")
temp_nsw$Date <- as.Date(temp_nsw$Date, "%Y:%m:%d")
dem_nsw$Time <- strptime(dem_nsw$Time, "%H:%M:%S", tz = "Australia/Sydney")
dem_nsw$Date <- as.Date(dem_nsw$Date, "%Y:%m:%d")
as.data.frame(table(minute(temp_nsw$Time)))
as.data.frame(table(minute(dem_nsw$DATETIME)))
as.data.frame(table(minute(dem_nsw$Time)))
Now we can check if there are an appropriate number of 0 and 30 min time values to spread across our entire set.
as.data.frame(table(minute(temp_nsw$Time)))
as.data.frame(table(minute(dem_nsw$Time)))
```{r}
subset(temp_nsw, minute(temp_nsw$Time) == NaN)
# Create the dataframes containing temp and demand
NSW_df <- merge(temp_nsw, dem_nsw)#, by = 'DATETIME')
library(lubridate)
#library(readr)
library(car)
library(ggplot2)
library(tidyverse)
# Import temperature and demand datasets
setwd('../data/')
temp_nsw <- read.csv(unz('H03-2021/temperature_nsw.csv.zip', 'temperature_nsw.csv'), header = T)
#temp_vic <- read.csv(unz('H06-2021/d.zip', 'd/temprature_vic.csv'), header = T)
#temp_qld <- read.csv(unz('H06-2021/d.zip', 'd/temprature_qld.csv'), header = T)
#temp_sa <- read.csv(unz('H06-2021/d.zip', 'd/temprature_sa.csv'), header = T)
dem_nsw <- read.csv(unz('H03-2021/totaldemand_nsw.csv.zip', 'totaldemand_nsw.csv'), header = T)
#dem_vic <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_vic.csv'), header = T)
#dem_qld <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_qld.csv'), header = T)
#dem_sa <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_sa.csv'), header = T)
# Can we get this to work?
#fcst_nsw <- read.csv(unz('H03-2021/forecastdemand_nsw.csv.zip.partaa', 'forecastdemand_nsw.csv'), header = T)
## Have a look at how our data has been imported
#head(temp_nsw)
#head(temp_vic)
#head(temp_qld)
#head(temp_sa)
# We can merge the demand and temperature data. This is essentially what we should be working with in order to create our models
# Get rid of columns that we don't require
temp_nsw <- temp_nsw[-c(1)]
#temp_vic <- temp_vic[-c(1)]
#temp_qld <- temp_qld[-c(1)]
#temp_sa <- temp_sa[-c(1, 2)]
dem_nsw <- dem_nsw[-c(3)]
#dem_vic <- dem_vic[-c(3)]
#dem_qld <- dem_qld[-c(3)]
#dem_sa <- dem_sa[-c(3)]
# Convert the DATETIME columns to similar formats in order to merge successfully
########### For some reason temp_vic and dem_vic will not recognize/convert to AEDT which it should be. I have made a work-around by converting everything to AEST however the values of time_vic and dem_vic are incorrect as it gets set as AEST straight away instead of being set to AEDT then converted to AEST. Maybe this an issue with my local system timezone?
########### I note here that unless you use head(temp_vic) the datetimes do not explicitly state that they are AEDT/AEST etc
temp_nsw$DATETIME <- as.POSIXct(temp_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#temp_vic$DATETIME <- as.POSIXct(temp_vic$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Melbourne")
#temp_qld$DATETIME <- as.POSIXct(temp_qld$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Brisbane")
#temp_sa$DATETIME <- as.POSIXct(temp_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
dem_nsw$DATETIME <- as.POSIXct(dem_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#dem_vic$DATETIME <- as.POSIXct(dem_vic$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Melbourne")
#dem_qld$DATETIME <- as.POSIXct(dem_qld$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Brisbane")
#dem_sa$DATETIME <- as.POSIXct(dem_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
## Convert all times to AEST ##### This is only necessary if we wish to compare the data across the whole country at a single point in time.
#temp_nsw$DATETIME <- with_tz(temp_nsw$DATETIME, tzone = "Australia/Brisbane")
#temp_qld$DATETIME <- with_tz(temp_qld$DATETIME, tzone = "Australia/Brisbane")
#temp_sa$DATETIME <- with_tz(temp_sa$DATETIME, tzone = "Australia/Brisbane")
#dem_nsw$DATETIME <- with_tz(dem_nsw$DATETIME, tzone = "Australia/Brisbane")
#dem_qld$DATETIME <- with_tz(dem_qld$DATETIME, tzone = "Australia/Brisbane")
#dem_sa$DATETIME <- with_tz(dem_sa$DATETIME, tzone = "Australia/Brisbane")
# Split DATETIME column into Date and Time columns
temp_nsw$Date <- as.Date(temp_nsw$DATETIME)
temp_nsw$Time <- format(as.POSIXct(temp_nsw$DATETIME), format = "%H:%M:%S")
temp_nsw <- temp_nsw[-c(1)]
dem_nsw$Date <- as.Date(dem_nsw$DATETIME)
dem_nsw$Time <- format(as.POSIXct(dem_nsw$DATETIME), format = "%H:%M:%S")
dem_nsw <- dem_nsw[-c(1)]
temp_nsw[rowSums(is.na(temp_nsw)) > 0, ]
dem_nsw[rowSums(is.na(dem_nsw)) > 0, ]
# Fill in the missing date values with the last valid date
temp_nsw <- temp_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
dem_nsw <- dem_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
# Get rid of the extra row of NaN values for temp_nsw
temp_nsw <- temp_nsw[-14314, ]
# Create lists of row index values
missing_temp_dates <- which(is.na(temp_nsw$Time))
missing_dem_dates <- which(is.na(dem_nsw$Time))
# Split these lists into indexs that correspond to 2:00 and 2:30
two_oclock_temp_rows <- missing_temp_dates[seq(1, length(missing_temp_dates), 2)]
two_thirty_temp_rows <- missing_temp_dates[seq(0, length(missing_temp_dates), 2)]
two_oclock_dem_rows <- missing_dem_dates[seq(1, length(missing_dem_dates), 2)]
two_thirty_dem_rows <- missing_dem_dates[seq(0, length(missing_dem_dates), 2)]
# Enter the values as required
for (i in two_oclock_temp_rows){temp_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_temp_rows){temp_nsw[i, 3] <- '02:30:00'}
for (i in two_oclock_dem_rows){dem_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_dem_rows){dem_nsw[i, 3] <- '02:30:00'}
# Make sure all columns are in the correct format
temp_nsw$Time <- strptime(temp_nsw$Time, "%H:%M:%S")
temp_nsw$Date <- as.Date(temp_nsw$Date, "%Y:%m:%d")
dem_nsw$Time <- strptime(dem_nsw$Time, "%H:%M:%S")
dem_nsw$Date <- as.Date(dem_nsw$Date, "%Y:%m:%d")
as.data.frame(table(minute(temp_nsw$Time)))
as.data.frame(table(minute(dem_nsw$Time)))
## Only want to include data every 30 minutes for analysis
#temp_nsw <- subset(temp_nsw, minute(temp_nsw$DATETIME) == c(0, 30))
#dem_nsw <- subset(dem_nsw, minute(dem_nsw$DATETIME) == c(0, 30))
# Create the dataframes containing temp and demand
NSW_df <- merge(temp_nsw, dem_nsw)#, by = 'DATETIME')
#VIC_df <- merge(temp_vic, dem_vic, by = 'DATETIME')
#QLD_df <- merge(temp_qld, dem_qld, by = 'DATETIME')
#SA_df <- merge(temp_sa, dem_sa, by = 'DATETIME')
library(lubridate)
#library(readr)
library(car)
library(ggplot2)
library(tidyverse)
# Import temperature and demand datasets
setwd('../data/')
temp_nsw <- read.csv(unz('H03-2021/temperature_nsw.csv.zip', 'temperature_nsw.csv'), header = T)
#temp_vic <- read.csv(unz('H06-2021/d.zip', 'd/temprature_vic.csv'), header = T)
#temp_qld <- read.csv(unz('H06-2021/d.zip', 'd/temprature_qld.csv'), header = T)
#temp_sa <- read.csv(unz('H06-2021/d.zip', 'd/temprature_sa.csv'), header = T)
dem_nsw <- read.csv(unz('H03-2021/totaldemand_nsw.csv.zip', 'totaldemand_nsw.csv'), header = T)
#dem_vic <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_vic.csv'), header = T)
#dem_qld <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_qld.csv'), header = T)
#dem_sa <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_sa.csv'), header = T)
# Can we get this to work?
#fcst_nsw <- read.csv(unz('H03-2021/forecastdemand_nsw.csv.zip.partaa', 'forecastdemand_nsw.csv'), header = T)
## Have a look at how our data has been imported
#head(temp_nsw)
#head(temp_vic)
#head(temp_qld)
#head(temp_sa)
# We can merge the demand and temperature data. This is essentially what we should be working with in order to create our models
# Get rid of columns that we don't require
temp_nsw <- temp_nsw[-c(1)]
#temp_vic <- temp_vic[-c(1)]
#temp_qld <- temp_qld[-c(1)]
#temp_sa <- temp_sa[-c(1, 2)]
dem_nsw <- dem_nsw[-c(3)]
#dem_vic <- dem_vic[-c(3)]
#dem_qld <- dem_qld[-c(3)]
#dem_sa <- dem_sa[-c(3)]
# Convert the DATETIME columns to similar formats in order to merge successfully
########### For some reason temp_vic and dem_vic will not recognize/convert to AEDT which it should be. I have made a work-around by converting everything to AEST however the values of time_vic and dem_vic are incorrect as it gets set as AEST straight away instead of being set to AEDT then converted to AEST. Maybe this an issue with my local system timezone?
########### I note here that unless you use head(temp_vic) the datetimes do not explicitly state that they are AEDT/AEST etc
temp_nsw$DATETIME <- as.POSIXct(temp_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#temp_vic$DATETIME <- as.POSIXct(temp_vic$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Melbourne")
#temp_qld$DATETIME <- as.POSIXct(temp_qld$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Brisbane")
#temp_sa$DATETIME <- as.POSIXct(temp_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
dem_nsw$DATETIME <- as.POSIXct(dem_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#dem_vic$DATETIME <- as.POSIXct(dem_vic$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Melbourne")
#dem_qld$DATETIME <- as.POSIXct(dem_qld$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Brisbane")
#dem_sa$DATETIME <- as.POSIXct(dem_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
## Convert all times to AEST ##### This is only necessary if we wish to compare the data across the whole country at a single point in time.
#temp_nsw$DATETIME <- with_tz(temp_nsw$DATETIME, tzone = "Australia/Brisbane")
#temp_qld$DATETIME <- with_tz(temp_qld$DATETIME, tzone = "Australia/Brisbane")
#temp_sa$DATETIME <- with_tz(temp_sa$DATETIME, tzone = "Australia/Brisbane")
#dem_nsw$DATETIME <- with_tz(dem_nsw$DATETIME, tzone = "Australia/Brisbane")
#dem_qld$DATETIME <- with_tz(dem_qld$DATETIME, tzone = "Australia/Brisbane")
#dem_sa$DATETIME <- with_tz(dem_sa$DATETIME, tzone = "Australia/Brisbane")
# Split DATETIME column into Date and Time columns
temp_nsw$Date <- as.Date(temp_nsw$DATETIME)
temp_nsw$Time <- format(as.POSIXct(temp_nsw$DATETIME), format = "%H:%M:%S")
temp_nsw <- temp_nsw[-c(1)]
dem_nsw$Date <- as.Date(dem_nsw$DATETIME)
dem_nsw$Time <- format(as.POSIXct(dem_nsw$DATETIME), format = "%H:%M:%S")
dem_nsw <- dem_nsw[-c(1)]
temp_nsw[rowSums(is.na(temp_nsw)) > 0, ]
dem_nsw[rowSums(is.na(dem_nsw)) > 0, ]
# Fill in the missing date values with the last valid date
temp_nsw <- temp_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
dem_nsw <- dem_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
# Get rid of the extra row of NaN values for temp_nsw
temp_nsw <- temp_nsw[-14314, ]
# Create lists of row index values
missing_temp_dates <- which(is.na(temp_nsw$Time))
missing_dem_dates <- which(is.na(dem_nsw$Time))
# Split these lists into indexs that correspond to 2:00 and 2:30
two_oclock_temp_rows <- missing_temp_dates[seq(1, length(missing_temp_dates), 2)]
two_thirty_temp_rows <- missing_temp_dates[seq(0, length(missing_temp_dates), 2)]
two_oclock_dem_rows <- missing_dem_dates[seq(1, length(missing_dem_dates), 2)]
two_thirty_dem_rows <- missing_dem_dates[seq(0, length(missing_dem_dates), 2)]
# Enter the values as required
for (i in two_oclock_temp_rows){temp_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_temp_rows){temp_nsw[i, 3] <- '02:30:00'}
for (i in two_oclock_dem_rows){dem_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_dem_rows){dem_nsw[i, 3] <- '02:30:00'}
## Make sure all columns are in the correct format
#temp_nsw$Time <- strptime(temp_nsw$Time, "%H:%M:%S")
#temp_nsw$Date <- as.Date(temp_nsw$Date, "%Y:%m:%d")
#dem_nsw$Time <- strptime(dem_nsw$Time, "%H:%M:%S")
#dem_nsw$Date <- as.Date(dem_nsw$Date, "%Y:%m:%d")
as.data.frame(table(minute(temp_nsw$Time)))
## Only want to include data every 30 minutes for analysis
#temp_nsw <- subset(temp_nsw, minute(temp_nsw$DATETIME) == c(0, 30))
#dem_nsw <- subset(dem_nsw, minute(dem_nsw$DATETIME) == c(0, 30))
# Create the dataframes containing temp and demand
NSW_df <- merge(temp_nsw, dem_nsw)#, by = 'DATETIME')
#VIC_df <- merge(temp_vic, dem_vic, by = 'DATETIME')
#QLD_df <- merge(temp_qld, dem_qld, by = 'DATETIME')
#SA_df <- merge(temp_sa, dem_sa, by = 'DATETIME')
unique(temp_nsw)
unique(temp_nsw$Time)
unique(dem_nsw$Time)
as.data.frame(table(dem_nsw$Time))
# Create the dataframes containing temp and demand
NSW_df <- merge(dem_nsw, temp_nsw, all.x = TRUE)#, by = 'DATETIME')
View(NSW_df)
NSW_df[rowSums(is.na(NSW_df)) > 0, ]
# Merge temp and demand data sets, keeping all dem values
NSW_df <- merge(dem_nsw, temp_nsw, all.x = TRUE, all.y = FALSE)#, by = 'DATETIME')
library(lubridate)
#library(readr)
library(car)
library(ggplot2)
library(tidyverse)
# Import temperature and demand datasets
setwd('../data/')
temp_nsw <- read.csv(unz('H03-2021/temperature_nsw.csv.zip', 'temperature_nsw.csv'), header = T)
#temp_vic <- read.csv(unz('H06-2021/d.zip', 'd/temprature_vic.csv'), header = T)
#temp_qld <- read.csv(unz('H06-2021/d.zip', 'd/temprature_qld.csv'), header = T)
#temp_sa <- read.csv(unz('H06-2021/d.zip', 'd/temprature_sa.csv'), header = T)
dem_nsw <- read.csv(unz('H03-2021/totaldemand_nsw.csv.zip', 'totaldemand_nsw.csv'), header = T)
#dem_vic <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_vic.csv'), header = T)
#dem_qld <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_qld.csv'), header = T)
#dem_sa <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_sa.csv'), header = T)
# Can we get this to work?
#fcst_nsw <- read.csv(unz('H03-2021/forecastdemand_nsw.csv.zip.partaa', 'forecastdemand_nsw.csv'), header = T)
## Have a look at how our data has been imported
#head(temp_nsw)
#head(temp_vic)
#head(temp_qld)
#head(temp_sa)
# We can merge the demand and temperature data. This is essentially what we should be working with in order to create our models
# Get rid of columns that we don't require
temp_nsw <- temp_nsw[-c(1)]
#temp_vic <- temp_vic[-c(1)]
#temp_qld <- temp_qld[-c(1)]
#temp_sa <- temp_sa[-c(1, 2)]
dem_nsw <- dem_nsw[-c(3)]
#dem_vic <- dem_vic[-c(3)]
#dem_qld <- dem_qld[-c(3)]
#dem_sa <- dem_sa[-c(3)]
# Convert the DATETIME columns to similar formats in order to merge successfully
########### For some reason temp_vic and dem_vic will not recognize/convert to AEDT which it should be. I have made a work-around by converting everything to AEST however the values of time_vic and dem_vic are incorrect as it gets set as AEST straight away instead of being set to AEDT then converted to AEST. Maybe this an issue with my local system timezone?
########### I note here that unless you use head(temp_vic) the datetimes do not explicitly state that they are AEDT/AEST etc
temp_nsw$DATETIME <- as.POSIXct(temp_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#temp_vic$DATETIME <- as.POSIXct(temp_vic$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Melbourne")
#temp_qld$DATETIME <- as.POSIXct(temp_qld$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Brisbane")
#temp_sa$DATETIME <- as.POSIXct(temp_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
dem_nsw$DATETIME <- as.POSIXct(dem_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#dem_vic$DATETIME <- as.POSIXct(dem_vic$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Melbourne")
#dem_qld$DATETIME <- as.POSIXct(dem_qld$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Brisbane")
#dem_sa$DATETIME <- as.POSIXct(dem_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
## Convert all times to AEST ##### This is only necessary if we wish to compare the data across the whole country at a single point in time.
#temp_nsw$DATETIME <- with_tz(temp_nsw$DATETIME, tzone = "Australia/Brisbane")
#temp_qld$DATETIME <- with_tz(temp_qld$DATETIME, tzone = "Australia/Brisbane")
#temp_sa$DATETIME <- with_tz(temp_sa$DATETIME, tzone = "Australia/Brisbane")
#dem_nsw$DATETIME <- with_tz(dem_nsw$DATETIME, tzone = "Australia/Brisbane")
#dem_qld$DATETIME <- with_tz(dem_qld$DATETIME, tzone = "Australia/Brisbane")
#dem_sa$DATETIME <- with_tz(dem_sa$DATETIME, tzone = "Australia/Brisbane")
# Split DATETIME column into Date and Time columns
temp_nsw$Date <- as.Date(temp_nsw$DATETIME)
temp_nsw$Time <- format(as.POSIXct(temp_nsw$DATETIME), format = "%H:%M:%S")
temp_nsw <- temp_nsw[-c(1)]
dem_nsw$Date <- as.Date(dem_nsw$DATETIME)
dem_nsw$Time <- format(as.POSIXct(dem_nsw$DATETIME), format = "%H:%M:%S")
dem_nsw <- dem_nsw[-c(1)]
temp_nsw[rowSums(is.na(temp_nsw)) > 0, ]
dem_nsw[rowSums(is.na(dem_nsw)) > 0, ]
# Fill in the missing date values with the last valid date
temp_nsw <- temp_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
dem_nsw <- dem_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
# Get rid of the extra row of NaN values for temp_nsw
temp_nsw <- temp_nsw[-14314, ]
# Create lists of row index values
missing_temp_dates <- which(is.na(temp_nsw$Time))
missing_dem_dates <- which(is.na(dem_nsw$Time))
# Split these lists into indexs that correspond to 2:00 and 2:30
two_oclock_temp_rows <- missing_temp_dates[seq(1, length(missing_temp_dates), 2)]
two_thirty_temp_rows <- missing_temp_dates[seq(0, length(missing_temp_dates), 2)]
two_oclock_dem_rows <- missing_dem_dates[seq(1, length(missing_dem_dates), 2)]
two_thirty_dem_rows <- missing_dem_dates[seq(0, length(missing_dem_dates), 2)]
# Enter the values as required
for (i in two_oclock_temp_rows){temp_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_temp_rows){temp_nsw[i, 3] <- '02:30:00'}
for (i in two_oclock_dem_rows){dem_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_dem_rows){dem_nsw[i, 3] <- '02:30:00'}
## Make sure all columns are in the correct format
#temp_nsw$Time <- strptime(temp_nsw$Time, "%H:%M:%S")
#temp_nsw$Date <- as.Date(temp_nsw$Date, "%Y:%m:%d")
#dem_nsw$Time <- strptime(dem_nsw$Time, "%H:%M:%S")
#dem_nsw$Date <- as.Date(dem_nsw$Date, "%Y:%m:%d")
as.data.frame(table(dem_nsw$Time))
# Merge temp and demand data sets, keeping all dem values
NSW_df <- merge(dem_nsw, temp_nsw, all.x = TRUE, all.y = FALSE)#, by = 'DATETIME')
View(dem_nsw)
View(dem_nsw)
View(NSW_df)
View(temp_nsw)
View(NSW_df)
View(dem_nsw)
View(NSW_df)
as.data.frame(table(NSW_df$Time))
as.data.frame(table(dem_nsw$Time))
library(dplyr)
NSW_df <- lef_join(dem_nsw, temp_nsw)
NSW_df <- left_join(dem_nsw, temp_nsw)
library(dplyr)
NSW_df <- left_join(dem_nsw, temp_nsw)
library(lubridate)
#library(readr)
library(car)
library(ggplot2)
library(tidyverse)
# Import temperature and demand datasets
setwd('../data/')
temp_nsw <- read.csv(unz('H03-2021/temperature_nsw.csv.zip', 'temperature_nsw.csv'), header = T)
#temp_vic <- read.csv(unz('H06-2021/d.zip', 'd/temprature_vic.csv'), header = T)
#temp_qld <- read.csv(unz('H06-2021/d.zip', 'd/temprature_qld.csv'), header = T)
#temp_sa <- read.csv(unz('H06-2021/d.zip', 'd/temprature_sa.csv'), header = T)
dem_nsw <- read.csv(unz('H03-2021/totaldemand_nsw.csv.zip', 'totaldemand_nsw.csv'), header = T)
#dem_vic <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_vic.csv'), header = T)
#dem_qld <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_qld.csv'), header = T)
#dem_sa <- read.csv(unz('H06-2021/d.zip', 'd/totaldemand_sa.csv'), header = T)
# Can we get this to work?
#fcst_nsw <- read.csv(unz('H03-2021/forecastdemand_nsw.csv.zip.partaa', 'forecastdemand_nsw.csv'), header = T)
## Have a look at how our data has been imported
#head(temp_nsw)
#head(temp_vic)
#head(temp_qld)
#head(temp_sa)
# We can merge the demand and temperature data. This is essentially what we should be working with in order to create our models
# Get rid of columns that we don't require
temp_nsw <- temp_nsw[-c(1)]
#temp_vic <- temp_vic[-c(1)]
#temp_qld <- temp_qld[-c(1)]
#temp_sa <- temp_sa[-c(1, 2)]
dem_nsw <- dem_nsw[-c(3)]
#dem_vic <- dem_vic[-c(3)]
#dem_qld <- dem_qld[-c(3)]
#dem_sa <- dem_sa[-c(3)]
# Convert the DATETIME columns to similar formats in order to merge successfully
########### For some reason temp_vic and dem_vic will not recognize/convert to AEDT which it should be. I have made a work-around by converting everything to AEST however the values of time_vic and dem_vic are incorrect as it gets set as AEST straight away instead of being set to AEDT then converted to AEST. Maybe this an issue with my local system timezone?
########### I note here that unless you use head(temp_vic) the datetimes do not explicitly state that they are AEDT/AEST etc
temp_nsw$DATETIME <- as.POSIXct(temp_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#temp_vic$DATETIME <- as.POSIXct(temp_vic$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Melbourne")
#temp_qld$DATETIME <- as.POSIXct(temp_qld$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Brisbane")
#temp_sa$DATETIME <- as.POSIXct(temp_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
dem_nsw$DATETIME <- as.POSIXct(dem_nsw$DATETIME, format = "%d/%m/%Y %H:%M", tz = "Australia/Sydney")
#dem_vic$DATETIME <- as.POSIXct(dem_vic$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Melbourne")
#dem_qld$DATETIME <- as.POSIXct(dem_qld$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Brisbane")
#dem_sa$DATETIME <- as.POSIXct(dem_sa$DATETIME, format = "%Y-%m-%d %H:%M:%S", tz = "Australia/Adelaide")
## Convert all times to AEST ##### This is only necessary if we wish to compare the data across the whole country at a single point in time.
#temp_nsw$DATETIME <- with_tz(temp_nsw$DATETIME, tzone = "Australia/Brisbane")
#temp_qld$DATETIME <- with_tz(temp_qld$DATETIME, tzone = "Australia/Brisbane")
#temp_sa$DATETIME <- with_tz(temp_sa$DATETIME, tzone = "Australia/Brisbane")
#dem_nsw$DATETIME <- with_tz(dem_nsw$DATETIME, tzone = "Australia/Brisbane")
#dem_qld$DATETIME <- with_tz(dem_qld$DATETIME, tzone = "Australia/Brisbane")
#dem_sa$DATETIME <- with_tz(dem_sa$DATETIME, tzone = "Australia/Brisbane")
# Split DATETIME column into Date and Time columns
temp_nsw$Date <- as.Date(temp_nsw$DATETIME)
temp_nsw$Time <- format(as.POSIXct(temp_nsw$DATETIME), format = "%H:%M:%S")
temp_nsw <- temp_nsw[-c(1)]
dem_nsw$Date <- as.Date(dem_nsw$DATETIME)
dem_nsw$Time <- format(as.POSIXct(dem_nsw$DATETIME), format = "%H:%M:%S")
dem_nsw <- dem_nsw[-c(1)]
temp_nsw[rowSums(is.na(temp_nsw)) > 0, ]
dem_nsw[rowSums(is.na(dem_nsw)) > 0, ]
# Fill in the missing date values with the last valid date
temp_nsw <- temp_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
dem_nsw <- dem_nsw %>%
mutate(Date = replace(Date, is.nan(Date), NA)) %>%
fill(Date)
# Get rid of the extra row of NaN values for temp_nsw
temp_nsw <- temp_nsw[-14314, ]
# Create lists of row index values
missing_temp_dates <- which(is.na(temp_nsw$Time))
missing_dem_dates <- which(is.na(dem_nsw$Time))
# Split these lists into indexs that correspond to 2:00 and 2:30
two_oclock_temp_rows <- missing_temp_dates[seq(1, length(missing_temp_dates), 2)]
two_thirty_temp_rows <- missing_temp_dates[seq(0, length(missing_temp_dates), 2)]
two_oclock_dem_rows <- missing_dem_dates[seq(1, length(missing_dem_dates), 2)]
two_thirty_dem_rows <- missing_dem_dates[seq(0, length(missing_dem_dates), 2)]
# Enter the values as required
for (i in two_oclock_temp_rows){temp_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_temp_rows){temp_nsw[i, 3] <- '02:30:00'}
for (i in two_oclock_dem_rows){dem_nsw[i, 3] <- '02:00:00'}
for (i in two_thirty_dem_rows){dem_nsw[i, 3] <- '02:30:00'}
## Make sure all columns are in the correct format
#temp_nsw$Time <- strptime(temp_nsw$Time, "%H:%M:%S")
#temp_nsw$Date <- as.Date(temp_nsw$Date, "%Y:%m:%d")
#dem_nsw$Time <- strptime(dem_nsw$Time, "%H:%M:%S")
#dem_nsw$Date <- as.Date(dem_nsw$Date, "%Y:%m:%d")
as.data.frame(table(dem_nsw$Time))
library(dplyr)
NSW_df <- left_join(dem_nsw, temp_nsw, by = c('Date', 'Time'))
NSW_df[rowSums(is.na(NSW_df)) > 0, ]
as.data.frame(table(NSW_df$Time))
as.data.frame(table(temp_nsw$Time))
NSW_df[duplicated(NSW_df),]
duplicated(NSW_df[,2:3])
NSW_df[duplicated(NSW_df[,2:3]),]
NSW_df %>%
distinct(Date, Time, .keep_all = TRUE)
NSW_df %>%
distinct(Date, Time, .keep_all = F)
NSW_df %>%
distinct(Date, Time, .keep_all = TRUE)
NSW_df %>%
distinct(Date, Time)#, .keep_all = TRUE)
NSW_df %>%
distinct(Date, Time), .keep_all = TRUE)
NSW_df %>%
distinct(Date, Time), .keep_all = TRUE)
NSW_df %>%
distinct(Date, Time), .keep_all = TRUE
NSW_df %>%
distinct(Date, Time, .keep_all = TRUE)
dem_nsw %>%
distinct(Date, Time, .keep_all = TRUE)
temp_nsw %>%
distinct(Date, Time, .keep_all = TRUE)
NSW_df <- NSW_df(distinct(Date, Time, .keep_all = TRUE))
NSW_df <- NSW_df%>%
distinct(Date, Time, .keep_all = TRUE)
