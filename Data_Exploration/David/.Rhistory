#NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
#NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
#NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
#NSW_df <- NSW_df[, -3]
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
#NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
#NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
NSW_df <- NSW_df[, -c(3)]
#NSW_df$Time[NSW_df$Time < 1] <- 0
#NSW_df$Time[NSW_df$Time > 40] <- 0
#NSW_df$Time[NSW_df$Time > 0] <- 1
#NSW_df$Is_Peak <- NSW_df$Time
#NSW_df <- NSW_df[, -5]
NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
NSW_df <- NSW_df[, -5]
#NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
#NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
#NSW_df <- NSW_df[, -3]
# Normalize the data
min <- min(NSW_df$TEMPERATURE)
max <- max(NSW_df$TEMPERATURE)
mean <- mean(NSW_df$TEMPERATURE)
std <- sd(NSW_df$TEMPERATURE)
NSW_df$TEMPERATURE <- ((NSW_df$TEMPERATURE - min) / (max - min))
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
#NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
#NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
NSW_df <- NSW_df[, -c(3)]
#NSW_df$Time[NSW_df$Time < 1] <- 0
#NSW_df$Time[NSW_df$Time > 40] <- 0
#NSW_df$Time[NSW_df$Time > 0] <- 1
#NSW_df$Is_Peak <- NSW_df$Time
#NSW_df <- NSW_df[, -5]
#NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
#NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
# Normalize the data
min <- min(NSW_df$TEMPERATURE)
max <- max(NSW_df$TEMPERATURE)
mean <- mean(NSW_df$TEMPERATURE)
std <- sd(NSW_df$TEMPERATURE)
NSW_df$TEMPERATURE <- ((NSW_df$TEMPERATURE - min) / (max - min))
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
NSW_df <- NSW_df[, -c(3)]
#NSW_df$Time[NSW_df$Time < 1] <- 0
#NSW_df$Time[NSW_df$Time > 40] <- 0
#NSW_df$Time[NSW_df$Time > 0] <- 1
NSW_df$Is_Peak <- NSW_df$Time
NSW_df <- NSW_df[, -5]
#NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
#NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
# Normalize the data
min <- min(NSW_df$TEMPERATURE)
max <- max(NSW_df$TEMPERATURE)
mean <- mean(NSW_df$TEMPERATURE)
std <- sd(NSW_df$TEMPERATURE)
NSW_df$TEMPERATURE <- ((NSW_df$TEMPERATURE - min) / (max - min))
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
#NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
#NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
NSW_df <- NSW_df[, -c(3)]
#NSW_df$Time[NSW_df$Time < 1] <- 0
#NSW_df$Time[NSW_df$Time > 40] <- 0
#NSW_df$Time[NSW_df$Time > 0] <- 1
NSW_df$Is_Peak <- NSW_df$Time
NSW_df <- NSW_df[, -5]
#NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
#NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
# Normalize the data
min <- min(NSW_df$TEMPERATURE)
max <- max(NSW_df$TEMPERATURE)
mean <- mean(NSW_df$TEMPERATURE)
std <- sd(NSW_df$TEMPERATURE)
NSW_df$TEMPERATURE <- ((NSW_df$TEMPERATURE - min) / (max - min))
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(hms)
library(Metrics)
# Import cleaned data
NSW_df <- read.csv("Cleaned_Data_w_fcst.csv")
NSW_df$DATETIME <- ymd_hms(NSW_df$DATETIME)
# Plot the temp and demand data per year
ggplot(NSW_df, aes(x = TEMPERATURE, y = TOTALDEMAND)) +
geom_point() +
facet_wrap(~year(DATETIME))
# Plot the temp and demand data on a dual y axis against time to see any correlation.
ggplot(NSW_df, aes(x = DATETIME)) +
geom_line(aes(y = TEMPERATURE), colour = 'red') +
geom_line(aes(y = TOTALDEMAND/400), colour = 'blue') +
scale_y_continuous(name = 'Temperature', sec.axis = sec_axis(~.*400, name = 'Demand'))
# Boxplot temp per month
ggplot(NSW_df, aes(x = month(DATETIME), y = TEMPERATURE, group = month(DATETIME))) + geom_boxplot() + xlim(0, 13)
# Boxplot demand per month
ggplot(NSW_df, aes(x = month(DATETIME), y = TOTALDEMAND, group = month(DATETIME))) + geom_boxplot() + xlim(0, 13)
# Calculate the absolute value of the difference between each temperature and the average temperature for that year.
NSW_df <- NSW_df %>%
mutate(Year = year(DATETIME)) %>%
group_by(Year) %>%
mutate(Temp_Fluctuation = abs(TEMPERATURE - mean(TEMPERATURE)))
# Plot
ggplot(NSW_df, aes(x = DATETIME)) +
geom_line(aes(y = Temp_Fluctuation), colour = 'red') +
geom_line(aes(y = TOTALDEMAND/250), colour = 'blue') +
scale_y_continuous(name = 'Temperature', sec.axis = sec_axis(~.*250, name = 'Demand')) +
facet_wrap(~year(DATETIME), scales = 'free')
# Plot demand against temperature fluctuation per year
ggplot(NSW_df, aes(x = Temp_Fluctuation, y = TOTALDEMAND)) +
geom_point() +
geom_smooth(method = lm) +
facet_wrap(~year(DATETIME))
# First linear model between temp and demand
lm1 <- lm(TOTALDEMAND ~ TEMPERATURE, data = NSW_df)
summary(lm1)
plot(lm1)
NSW_df$lm1_fcst <- predict(lm1)
NSW_df$lm1_res <- NSW_df$TOTALDEMAND - NSW_df$lm1_fcst
# A linear model between temp fluctuation away from the yearly average will likely fix the Residuals vs fitted graph
lm2 <- lm(TOTALDEMAND ~ Temp_Fluctuation, data = NSW_df)
summary(lm2)
plot(lm2)
NSW_df$lm2_fcst <- predict(lm2)
NSW_df$lm2_res <- NSW_df$TOTALDEMAND - NSW_df$lm2_fcst
## Boxplots
#boxplot(NSW_df$Diff1, NSW_df$Diff32, NSW_df$lm1_res, NSW_df$lm2_res)
# Caluculate five number summaries
fivenum(NSW_df$Fcst1_res)
fivenum(NSW_df$Fcst32_res)
fivenum(NSW_df$lm1_res)
fivenum(NSW_df$lm2_res)
# Calculate RSME
print("RSME")
sqrt(mean(NSW_df$Fcst1_res^2))
sqrt(mean(NSW_df$Fcst32_res^2))
sqrt(mean((NSW_df$lm1_res)^2))
sqrt(mean((NSW_df$lm2_res)^2))
# Calculate MAE
print("MAE")
mae(NSW_df$TOTALDEMAND, NSW_df$Fcst1)
mae(NSW_df$TOTALDEMAND, NSW_df$Fcst32)
mae(NSW_df$TOTALDEMAND, NSW_df$lm1_fcst)
mae(NSW_df$TOTALDEMAND, NSW_df$lm2_fcst)
# Plot demand over different time intervals to see any trends
ggplot(NSW_df, aes(x = year(DATETIME), y = TOTALDEMAND, group = year(DATETIME))) + geom_boxplot()
ggplot(NSW_df, aes(x = week(DATETIME), y = TOTALDEMAND, group = week(DATETIME))) + geom_boxplot()
ggplot(NSW_df, aes(x = wday(DATETIME), y = TOTALDEMAND, group = wday(DATETIME))) + geom_boxplot()
ggplot(NSW_df, aes(x = as_hms(DATETIME), y = TOTALDEMAND, group = as_hms(DATETIME))) + geom_boxplot()
View(test_)
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
#NSW_df <- NSW_df[, -c(3)]
NSW_df$Time[NSW_df$Time < 1] <- 0
NSW_df$Time[NSW_df$Time > 40] <- 0
NSW_df$Time[NSW_df$Time > 0] <- 1
NSW_df$Is_Peak <- NSW_df$Time
#NSW_df <- NSW_df[, -5]
NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
M <- cor(NSW_df)
corrplot(M, method = "number")
library(corrplot)
M <- cor(NSW_df)
corrplot(M, method = "number")
lm1 <- lm(formula = TOTALDEMAND ~ ., data = NSW_df)
summary(lm1)
predictions <- lm1 %>% predict(NSW_df)
RMSE(predictions, NSW_df$TOTALDEMAND)
NSW_df2 <- NSW_df[, c(1, 2, 3, 6, 12)]
lm2 <- lm(formula = TOTALDEMAND ~ ., data = NSW_df2)
summary(lm2)
predictions2 <- lm2 %>% predict(NSW_df2)
RMSE(predictions2, NSW_df2$TOTALDEMAND)
#NSW_df <- NSW_df[, c(1, 2, 3, 4, 6, 8)]
#M2 <- cor(NSW_df)
#corrplot(M2, method = "number")
#lm1 <- lm(formula = TOTALDEMAND ~ ., data = NSW_df)
#summary(lm1)
#predictions <- lm1 %>% predict(NSW_df)
#RMSE(predictions, NSW_df$TOTALDEMAND)
library(lmtest)
bptest(lm2)
summary(rr.huber <- rlm(Glucose ~ Pregnancies + Outcome + Age + DiabetesPedigreeFunction + BMI + Insulin + SkinThickness + BloodPressure, data=diabetes1))
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
library(MASS)
summary(rr.huber <- rlm(TOTALDEMAND ~ ., data = NSW_df2))
abs(qt(0.05/2, 196507))
NSW_df <- NSW_df[, c(1,2)]
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
maxmindf <- as.data.frame(lapply(NSW_df, normalize))
attach(maxmindf)
maxmindf<-as.matrix(maxmindf)
View(maxmindf)
ind <- sample(2, nrow(maxmindf), replace=TRUE, prob = c(0.7,0.3))
X_train <- maxmindf[ind==1, 1:4]
ind <- sample(2, nrow(maxmindf), replace=TRUE, prob = c(0.7,0.3))
X_train <- maxmindf[ind==1, 2]
X_val <- maxmindf[ind==2, 2]
y_train <- maxmindf[ind==1, 1]
y_val <- maxmindf[ind==2, 1]
model <- keras_model_sequential()
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
#NSW_df <- NSW_df[, -c(3)]
NSW_df$Time[NSW_df$Time < 1] <- 0
NSW_df$Time[NSW_df$Time > 40] <- 0
NSW_df$Time[NSW_df$Time > 0] <- 1
NSW_df$Is_Peak <- NSW_df$Time
#NSW_df <- NSW_df[, -5]
NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
M <- cor(NSW_df)
corrplot(M, method = "number")
library(corrplot)
M <- cor(NSW_df)
corrplot(M, method = "number")
NSW_df2 <- NSW_df[, c(1, 2, 3, 6, 12)]
lm2 <- lm(formula = TOTALDEMAND ~ ., data = NSW_df2)
summary(lm2)
predictions2 <- lm2 %>% predict(NSW_df2)
RMSE(predictions2, NSW_df2$TOTALDEMAND)
library(lmtest)
library(MASS)
bptest(lm2)
summary(rr.huber <- rlm(TOTALDEMAND ~ ., data = NSW_df2))
abs(qt(0.05/2, 196507))
NSW_df <- NSW_df[, c(1,2)]
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
maxmindf <- as.data.frame(lapply(NSW_df, normalize))
attach(maxmindf)
maxmindf<-as.matrix(maxmindf)
ind <- sample(2, nrow(maxmindf), replace=TRUE, prob = c(0.7,0.3))
X_train <- maxmindf[ind==1, 2]
X_val <- maxmindf[ind==2, 2]
y_train <- maxmindf[ind==1, 1]
y_val <- maxmindf[ind==2, 1]
model <- keras_model_sequential()
model %>%
layer_dense(units = 9, activation = 'relu', kernel_initializer='RandomNormal', input_shape = c(4)) %>%
layer_dense(units = 60, activation = 'relu') %>%
layer_dense(units = 1, activation = 'linear')
summary(model)
model %>% compile(
loss = 'mean_squared_error',
optimizer = 'adam',
metrics = c('mae')
)
history <- model %>% fit(
X_train, y_train,
epochs = 30, batch_size = 50,
validation_split = 0.2
)
model %>% compile(
loss = 'mean_squared_error',
optimizer = 'adam',
metrics = c('mae')
)
history <- model %>% fit(
X_train, y_train,
epochs = 30, batch_size = 50,
validation_split = 0.2
)
model %>% compile(
loss = 'mean_squared_error',
optimizer = 'adam',
metrics = c('mae')
)
history <- model %>% fit(
X_train, y_train,
epochs = 30, batch_size = 50,
validation_split = 0.2
)
model %>% compile(
loss = 'mean_squared_error',
optimizer = 'adam',
metrics = c('mae')
)
history <- model %>% fit(
X_train, y_train,
epochs = 30, batch_size = 50,
validation_split = 0.2
)
# Import libraries
library(lubridate)
library(ggplot2)
library(dplyr)
library(data.table)
library(hms)
library(keras)
library(tensorflow)
library(tidyverse)
library(caret)
library(doParallel)
library(chron)
# Import cleaned data
NSW_df <- read.csv("../../report/Cleaned_Data.csv")
# Convert date and time to a datetime
NSW_df$DATETIME <- paste(NSW_df$Date, NSW_df$Time)
NSW_df$DATETIME <- dmy_hm(NSW_df$DATETIME)
NSW_df <- NSW_df[, -c(2,3)]
# Group based on certain conditions to make plotting easier
NSW_df$Year <- year(NSW_df$DATETIME)
#NSW_df <- subset(NSW_df, Year == 2021)
NSW_df$Month <- month(NSW_df$DATETIME)
NSW_df$day <- day(NSW_df$DATETIME)
NSW_df$Is_Wknd <- grepl("S.+", weekdays(NSW_df$DATETIME))
NSW_df$Is_Wknd <- NSW_df$Is_Wknd * 1
NSW_df$Time <- (hour(NSW_df$DATETIME)*60 + minute(NSW_df$DATETIME))/30
#NSW_df <- NSW_df[, -c(3)]
NSW_df$Time[NSW_df$Time < 1] <- 0
NSW_df$Time[NSW_df$Time > 40] <- 0
NSW_df$Time[NSW_df$Time > 0] <- 1
NSW_df$Is_Peak <- NSW_df$Time
#NSW_df <- NSW_df[, -5]
NSW_df$Time_x <- sin(360/47 * NSW_df$Time)
NSW_df$Time_y <- cos(360/47 * NSW_df$Time)
#NSW_df <- NSW_df[, -5]
NSW_df$Month_x <- sin(360/12 * NSW_df$Month)
NSW_df$Month_y <- cos(360/12 * NSW_df$Month)
NSW_df <- NSW_df[, -3]
# Normalize the data
min <- min(NSW_df$TEMPERATURE)
max <- max(NSW_df$TEMPERATURE)
mean <- mean(NSW_df$TEMPERATURE)
std <- sd(NSW_df$TEMPERATURE)
NSW_df$TEMPERATURE <- ((NSW_df$TEMPERATURE - min) / (max - min))
# Split the data into training and testing set
set.seed(2)
index <- sample(1:nrow(NSW_df), round(0.75 * nrow(NSW_df)))
train_ <- NSW_df[index,]
test_ <- NSW_df[-index,]
model %>% compile(
loss = 'mean_squared_error',
optimizer = 'adam',
metrics = c('mae')
)
history <- model %>% fit(
train_,
epochs = 30, batch_size = 50,
validation_split = 0.2
)
